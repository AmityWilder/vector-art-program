use raylib::prelude::*;
use std::{ffi::{c_char, c_void}, ops::{Deref, DerefMut}, ptr::null_mut};

#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum MatrixMode {
    Modelview = ffi::RL_MODELVIEW as i32,
    Projection = ffi::RL_PROJECTION as i32,
    Texture = ffi::RL_TEXTURE as i32,
}

/// Face culling mode
#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum CullMode {
    Front = ffi::rlCullMode::RL_CULL_FACE_FRONT as i32,
    Back  = ffi::rlCullMode::RL_CULL_FACE_BACK as i32,
}

pub struct RlglMatrixMode<'a, T: ?Sized>(&'a mut T);

impl<'a, T: ?Sized> Deref for RlglMatrixMode<'a, T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<'a, T: ?Sized> DerefMut for RlglMatrixMode<'a, T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl<'a, T: ?Sized> Drop for RlglMatrixMode<'a, T> {
    /// Pop latest inserted matrix from stack
    fn drop(&mut self) {
        unsafe { ffi::rlPopMatrix(); }
    }
}

pub trait Rlgl: RaylibDraw {
    // Matrix state

    /// Choose the current matrix to be transformed
    #[inline]
    fn rl_matrix_mode(&mut self, mode: MatrixMode) {
        unsafe { ffi::rlMatrixMode(mode as i32); }
    }

    /// Push the current matrix to stack
    #[inline]
    fn rl_push_matrix(&mut self) -> RlglMatrixMode<'_, Self> {
        unsafe { ffi::rlPushMatrix(); }
        RlglMatrixMode(self)
    }

    /// Reset current matrix to identity matrix
    #[inline]
    fn rl_load_identity(&mut self) {
        unsafe { ffi::rlLoadIdentity(); }
    }

    /// Multiply the current matrix by a translation matrix
    #[inline]
    fn rl_translatef(x: f32, y: f32, z: f32) {
        unsafe { ffi::rlTranslatef(x, y, z); }
    }

    /// Multiply the current matrix by a rotation matrix \
    /// NOTE: The provided angle must be in degrees
    #[inline]
    fn rl_rotatef(angle: f32, x: f32, y: f32, z: f32) {
        unsafe { ffi::rlRotatef(angle, x, y, z); }
    }

    /// Multiply the current matrix by a scaling matrix
    #[inline]
    fn rl_scalef(x: f32, y: f32, z: f32) {
        unsafe { ffi::rlScalef(x, y, z); }
    }

    /// Multiply the current matrix by another matrix
    #[inline]
    fn rl_mult_matrixf(matf: &[f32; 16]) {
        unsafe { ffi::rlMultMatrixf(matf as *const f32); }
    }

    /// Multiply the current matrix by a perspective matrix generated by parameters
    #[inline]
    fn rl_frustum(left: f64, right: f64, bottom: f64, top: f64, znear: f64, zfar: f64) {
        unsafe { ffi::rlFrustum(left, right, bottom, top, znear, zfar); }
    }

    /// Multiply the current matrix by an orthographic matrix generated by parameters
    #[inline]
    fn rl_ortho(left: f64, right: f64, bottom: f64, top: f64, znear: f64, zfar: f64) {
        // NOTE: If left-right and top-botton values are equal it could create a division by zero,
        // response to it is platform/compiler dependant
        unsafe { ffi::rlOrtho(left, right, bottom, top, znear, zfar); }
    }

    /// Set the viewport area
    /// NOTE: We store current viewport dimensions
    #[inline]
    fn rl_viewport(x: i32, y: i32, width: i32, height: i32) {
        unsafe { ffi::rlViewport(x, y, width, height); }
    }

    // Vertex state

    /// Set current texture to use
    #[inline]
    fn rl_set_texture(&mut self, texture: impl AsRef<ffi::Texture2D>) -> RlglTexture<'_, Self> {
        unsafe { ffi::rlSetTexture(texture.as_ref().id); }
        RlglTexture(self)
    }

    /// Set current texture to use with that of `texShapes`
    #[inline]
    fn rl_set_texture_tex_shapes(&mut self) -> RlglTexture<'_, Self> {
        unsafe { ffi::rlSetTexture(tex_shapes().id); }
        RlglTexture(self)
    }

    /// Initialize drawing mode (how to organize vertex)
    #[inline]
    fn rl_begin_quads(&mut self) -> RaylibRlglQuads<'_, Self> {
        unsafe { ffi::rlBegin(ffi::RL_QUADS as i32); }
        RaylibRlglQuads(self)
    }

    /// Initialize drawing mode (how to organize vertex)
    #[inline]
    fn rl_begin_lines(&mut self) -> RaylibRlglLines<'_, Self> {
        unsafe { ffi::rlBegin(ffi::RL_LINES as i32); }
        RaylibRlglLines(self)
    }

    /// Initialize drawing mode (how to organize vertex)
    #[inline]
    fn rl_begin_triangles(&mut self) -> RaylibRlglTriangles<'_, Self> {
        unsafe { ffi::rlBegin(ffi::RL_TRIANGLES as i32); }
        RaylibRlglTriangles(self)
    }
}

impl<D: RaylibDraw> Rlgl for D {}

// Vertex buffers state

/// Enable vertex array (VAO, if supported)
#[inline]
pub fn rl_enable_vertex_array(vao_id: u32) -> bool {
    unsafe { ffi::rlEnableVertexArray(vao_id) }
}

/// Disable vertex array (VAO, if supported)
#[inline]
pub fn rl_disable_vertex_array() {
    unsafe { ffi::rlDisableVertexArray(); }
}

/// Enable vertex buffer (VBO)
#[inline]
pub fn rl_enable_vertex_buffer(id: u32) {
    unsafe { ffi::rlEnableVertexBuffer(id); }
}

/// Disable vertex buffer (VBO)
#[inline]
pub fn rl_disable_vertex_buffer() {
    unsafe { ffi::rlDisableVertexBuffer(); }
}

/// Enable vertex buffer element (VBO element)
#[inline]
pub fn rl_enable_vertex_buffer_element(id: u32) {
    unsafe { ffi::rlEnableVertexBufferElement(id); }
}

/// Disable vertex buffer element (VBO element)
#[inline]
pub fn rl_disable_vertex_buffer_element() {
    unsafe { ffi::rlDisableVertexBufferElement(); }
}

/// Enable vertex attribute index
#[inline]
pub fn rl_enable_vertex_attribute(index: u32) {
    unsafe { ffi::rlEnableVertexAttribute(index); }
}

/// Disable vertex attribute index
#[inline]
pub fn rl_disable_vertex_attribute(index: u32) {
    unsafe { ffi::rlDisableVertexAttribute(index); }
}

// Textures state

/// Select and active a texture slot
#[inline]
pub fn rl_active_texture_slot(slot: i32) {
    unsafe { ffi::rlActiveTextureSlot(slot); }
}

/// Enable texture
#[inline]
pub fn rl_enable_texture(id: u32) {
    unsafe { ffi::rlEnableTexture(id); }
}

/// Disable texture
#[inline]
pub fn rl_disable_texture() {
    unsafe { ffi::rlDisableTexture(); }
}

/// Enable texture cubemap
#[inline]
pub fn rl_enable_texture_cubemap(id: u32) {
    unsafe { ffi::rlEnableTextureCubemap(id); }
}

/// Disable texture cubemap
#[inline]
pub fn rl_disable_texture_cubemap() {
    unsafe { ffi::rlDisableTextureCubemap(); }
}

/// Set texture parameters (filter, wrap)
#[inline]
pub fn rl_texture_parameters(id: u32, param: i32, value: i32) {
    unsafe { ffi::rlTextureParameters(id, param, value); }
}

/// Set cubemap parameters (filter, wrap)
#[inline]
pub fn rl_cubemap_parameters(id: u32, param: i32, value: i32) {
    unsafe { ffi::rlCubemapParameters(id, param, value); }
}

//------------------------------------------------------------------------------------
// Functions Declaration - OpenGL style functions (common to 1.1, 3.3+, ES2)
// NOTE: This functions are used to completely abstract raylib code from OpenGL layer,
// some of them are direct wrappers over OpenGL calls, some others are custom
//------------------------------------------------------------------------------------

// Shader state

/// Enable shader program
pub fn rl_enable_shader(id: u32) {
    unsafe { ffi::rlEnableShader(id); }
}

/// Disable shader program
pub fn rl_disable_shader() {
    unsafe { ffi::rlDisableShader(); }
}

// Framebuffer state

/// Enable render texture (fbo)
pub fn rl_enable_framebuffer(id: u32) {
    unsafe { ffi::rlEnableFramebuffer(id); }
}

/// Disable render texture (fbo), return to default framebuffer
pub fn rl_disable_framebuffer() {
    unsafe { ffi::rlDisableFramebuffer(); }
}

/// Activate multiple draw color buffers
pub fn rl_active_draw_buffers(count: i32) {
    unsafe { ffi::rlActiveDrawBuffers(count); }
}

/// Blit active framebuffer to main framebuffer
pub fn rl_blit_framebuffer(
    src_x: i32,
    src_y: i32,
    src_width: i32,
    src_height: i32,
    dst_x: i32,
    dst_y: i32,
    dst_width: i32,
    dst_height: i32,
    buffer_mask: i32,
) {
    unsafe { ffi::rlBlitFramebuffer(src_x, src_y, src_width, src_height, dst_x, dst_y, dst_width, dst_height, buffer_mask); }
}

// General render state

pub struct ColorBlendHandle<'a, T: ?Sized>(&'a mut T);

impl<'a, T> Deref for ColorBlendHandle<'a, T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'a, T> DerefMut for ColorBlendHandle<'a, T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

/// Enable color blending
pub fn rl_enable_color_blend<D: RaylibDraw>(d: &mut D) -> ColorBlendHandle<'_, D> {
    unsafe { ffi::rlEnableColorBlend(); }
    ColorBlendHandle(d)
}

impl Drop for ColorBlendHandle {
    /// Disable color blending
    fn drop(&mut self) {
        unsafe { ffi::rlDisableColorBlend(); }
    }
}

pub struct DepthTestHandle(());

/// Enable depth test
pub fn rl_enable_depth_test() -> DepthTestHandle {
    unsafe { ffi::rlEnableDepthTest(); }
    DepthTestHandle(())
}

impl Drop for DepthTestHandle {
    /// Disable depth test
    fn drop(&mut self) {
        unsafe { ffi::rlDisableDepthTest(); }
    }
}

/// Enable depth write
pub fn rl_enable_depth_mask() {
    unsafe { ffi::rlEnableDepthMask(); }
}
/// Disable depth write
pub fn rl_disable_depth_mask() {
    unsafe { ffi::rlDisableDepthMask(); }
}
/// Enable backface culling
pub fn rl_enable_backface_culling() {
    unsafe { ffi::rlEnableBackfaceCulling(); }
}
/// Disable backface culling
pub fn rl_disable_backface_culling() {
    unsafe { ffi::rlDisableBackfaceCulling(); }
}
/// Set face culling mode
pub fn rl_set_cull_face(mode: CullMode) {
    unsafe { ffi::rlSetCullFace(mode as i32); }
}
/// Enable scissor test
pub fn rl_enable_scissor_test() {
    unsafe { ffi::rlEnableScissorTest(); }
}
/// Disable scissor test
pub fn rl_disable_scissor_test() {
    unsafe { ffi::rlDisableScissorTest(); }
}
/// Scissor test
pub fn rl_scissor(x: i32, y: i32, width: i32, height: i32) {
    unsafe { ffi::rlScissor(x, y, width, height); }
}
/// Enable wire mode
pub fn rl_enable_wire_mode() {
    unsafe { ffi::rlEnableWireMode(); }
}
///  Enable point mode
pub fn rl_enable_point_mode() {
    unsafe { ffi::rlEnablePointMode(); }
}
/// Disable wire mode ( and point ) maybe rename
pub fn rl_disable_wire_mode() {
    unsafe { ffi::rlDisableWireMode(); }
}
/// Set the line drawing width
pub fn rl_set_line_width(width: f32) {
    unsafe { ffi::rlSetLineWidth(width); }
}
/// Get the line drawing width
pub fn rl_get_line_width() -> f32 {
    unsafe { ffi::rlGetLineWidth() }
}
/// Enable line aliasing
pub fn rl_enable_smooth_lines() {
    unsafe { ffi::rlEnableSmoothLines(); }
}
/// Disable line aliasing
pub fn rl_disable_smooth_lines() {
    unsafe { ffi::rlDisableSmoothLines(); }
}
/// Enable stereo rendering
pub fn rl_enable_stereo_render() {
    unsafe { ffi::rlEnableStereoRender(); }
}
/// Disable stereo rendering
pub fn rl_disable_stereo_render() {
    unsafe { ffi::rlDisableStereoRender(); }
}
/// Check if stereo render is enabled
pub fn rl_is_stereo_render_enabled() -> bool {
    unsafe { ffi::rlIsStereoRenderEnabled() }
}

/// Clear color buffer with color
pub fn rl_clear_color(r: u8, g: u8, b: u8, a: u8) {
    unsafe { ffi::rlClearColor(r, g, b, a); }
}
/// Clear used screen buffers (color and depth)
pub fn rl_clear_screen_buffers() {
    unsafe { ffi::rlClearScreenBuffers(); }
}
/// Check and log OpenGL error codes
pub fn rl_check_errors() {
    unsafe { ffi::rlCheckErrors(); }
}
/// Set blending mode
pub fn rl_set_blend_mode(mode: BlendMode) {
    unsafe { ffi::rlSetBlendMode(mode as i32); }
}
/// Set blending mode factor and equation (using OpenGL factors)
pub fn rl_set_blend_factors(gl_src_factor: i32, gl_dst_factor: i32, gl_equation: i32) {
    unsafe { ffi::rlSetBlendFactors(gl_src_factor, gl_dst_factor, gl_equation); }
}
/// Set blending mode factors and equations separately (using OpenGL factors)
pub fn rl_set_blend_factors_separate(
    gl_src_rgb: i32,
    gl_dst_rgb: i32,
    gl_src_alpha: i32,
    gl_dst_alpha: i32,
    gl_eq_rgb: i32,
    gl_eq_alpha: i32,
) {
    unsafe { ffi::rlSetBlendFactorsSeparate(
        gl_src_rgb,
        gl_dst_rgb,
        gl_src_alpha,
        gl_dst_alpha,
        gl_eq_rgb,
        gl_eq_alpha,
    ); }
}

// Render batch management
// NOTE: rlgl provides a default render batch to behave like OpenGL 1.1 immediate mode
// but this render batch API is exposed in case of custom batches are required

/// Load a render batch system
pub fn rl_load_render_batch(num_buffers: i32, buffer_elements: i32) -> ffi::rlRenderBatch {
    unsafe { ffi::rlLoadRenderBatch(num_buffers, buffer_elements) }
}
/// Unload render batch system
pub fn rl_unload_render_batch(batch: ffi::rlRenderBatch) {
    unsafe { ffi::rlUnloadRenderBatch(batch); }
}
/// Draw render batch data (Update->Draw->Reset)
/// NOTE: We require a pointer to reset batch and increase current buffer (multi-buffer)
pub fn rl_draw_render_batch(mut batch: impl AsMut<ffi::rlRenderBatch>) {
    unsafe { ffi::rlDrawRenderBatch(batch.as_mut() as *mut ffi::rlRenderBatch); }
}
/// Set the active render batch for rlgl (NULL for default internal)
pub fn rl_set_render_batch_active(batch: Option<impl AsMut<ffi::rlRenderBatch>>) {
    unsafe { ffi::rlSetRenderBatchActive(batch.map_or(null_mut(), |mut batch| batch.as_mut() as *mut ffi::rlRenderBatch)); }
}
/// Update and draw internal render batch
pub fn rl_draw_render_batch_active() {
    unsafe { ffi::rlDrawRenderBatchActive(); }
}

/// Check internal buffer overflow for a given number of vertex
/// and force a [`ffi::rlRenderBatch`] draw call if required
pub fn rl_check_render_batch_limit(v_count: i32) -> bool {
    unsafe { ffi::rlCheckRenderBatchLimit(v_count) }
}

/// Set current texture for render batch and check buffers limits
pub fn rl_set_texture(id: u32) {
    unsafe { ffi::rlSetTexture(id); }
}

//------------------------------------------------------------------------------------------------------------------------

// Vertex buffers management
/// Load vertex array (vao) if supported
pub fn rl_load_vertex_array() -> u32 {
    unsafe { ffi::rlLoadVertexArray() }
}
/// Load a vertex buffer attribute
pub fn rl_load_vertex_buffer<T>(buffer: &mut [T], dynamic: bool) -> u32 {
    unsafe { ffi::rlLoadVertexBuffer(buffer, std::mem::size_of::<T>() * buffer.len(), dynamic) }
}
/// Load a new attributes element buffer
pub fn rl_load_vertex_buffer_element(buffer: *const c_void, size: i32, dynamic: bool) -> u32;
/// Update GPU buffer with new data
pub fn rl_update_vertex_buffer(buffer_id: u32, data: *const c_void, data_size: i32, offset: i32);
/// Update vertex buffer elements with new data
pub fn rl_update_vertex_buffer_elements(id: u32, data: *const c_void, data_size: i32, offset: i32);
pub fn rl_unload_vertex_array(vao_id: u32);
pub fn rl_unload_vertex_buffer(vbo_id: u32);
pub fn rl_set_vertex_attribute(index: u32, comp_size: i32, r#type: i32, normalized: bool, stride: i32, pointer: *const c_void);
pub fn rl_set_vertex_attribute_divisor(index: u32, divisor: i32);
/// Set vertex attribute default value
pub fn rl_set_vertex_attribute_default(loc_index: i32, value: *const c_void, attrib_type: i32, count: i32);
pub fn rl_draw_vertex_array(offset: i32, count: i32);
pub fn rl_draw_vertex_array_elements(offset: i32, count: i32, buffer: *const c_void);
pub fn rl_draw_vertex_array_instanced(offset: i32, count: i32, instances: i32);
pub fn rl_draw_vertex_array_elements_instanced(offset: i32, count: i32, buffer: *const c_void, instances: i32);

// Textures management
/// Load texture in GPU
pub fn rl_load_texture(data: *const c_void, width: i32, height: i32, format: i32, mipmap_count: i32) -> u32;
/// Load depth texture/renderbuffer (to be attached to fbo)
pub fn rl_load_texture_depth(width: i32, height: i32, use_render_buffer: bool) -> u32;
/// Load texture cubemap
pub fn rl_load_texture_cubemap(data: *const c_void, size: i32, format: i32) -> u32;
/// Update GPU texture with new data
pub fn rl_update_texture(id: u32, offset_x: i32, offset_y: i32, width: i32, height: i32, format: i32, data: *const c_void);
/// Get OpenGL internal formats
pub fn rl_get_gl_texture_formats(format: i32, gl_internal_format: *mut u32, gl_format: *mut u32, gl_type: *mut u32);
/// Get name string for pixel format
pub fn rl_get_pixel_format_name(format: u32) -> *const c_char; // is `char` `i8` or `u8`?
/// Unload texture from GPU memory
pub fn rl_unload_texture(id: u32);
/// Generate mipmap data for selected texture
pub fn rl_gen_texture_mipmaps(id: u32, width: i32, height: i32, format: i32, mipmaps: *mut i32);
/// Read texture pixel data
pub fn rl_read_texture_pixels(id: u32, width: i32, height: i32, format: i32) -> *mut c_void;
/// Read screen pixel data (color buffer)
pub fn rl_read_screen_pixels(width: i32, height: i32) -> *mut u8;

// Framebuffer management (fbo)
/// Load an empty framebuffer
pub fn rl_load_framebuffer(width: i32, height: i32) -> u32;
/// Attach texture/renderbuffer to a framebuffer
pub fn rl_framebuffer_attach(fbo_id: u32, tex_id: u32, attach_type: i32, tex_type: i32, mip_level: i32);
/// Verify framebuffer is complete
pub fn rlFramebufferComplete(id: u32) -> bool;
/// Delete framebuffer from GPU
pub fn rl_unload_framebuffer(id: u32);

// Shaders management
/// Load shader from code strings
pub fn rl_load_shader_code(vs_code: *const c_char, fs_code: *const c_char) -> u32;
/// Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)
pub fn rl_compile_shader(shader_code: *const c_char, r#type: i32) -> u32;
/// Load custom shader program
pub fn rl_load_shader_program(v_shader_id: u32, f_shader_id: u32) -> u32;
/// Unload shader program
pub fn rl_unload_shader_program(id: u32);
/// Get shader location uniform
pub fn rl_get_location_uniform(shader_id: u32, uniform_name: *const c_char) -> i32;
/// Get shader location attribute
pub fn rl_get_location_attrib(shader_id: u32, attrib_name: *const c_char) -> i32;
/// Set shader value uniform
pub fn rl_set_uniform(loc_index: i32, value: *const c_void, uniform_type: i32, count: i32);
/// Set shader value matrix
pub fn rl_set_uniform_matrix(loc_index: i32, mat: ffi::Matrix);
/// Set shader value sampler
pub fn rl_set_uniform_sampler(loc_index: i32, texture_id: u32);
/// Set shader currently active (id and locations)
pub fn rl_set_shader(id: u32, locs: *mut i32);

// Compute shader management
/// Load compute shader program
pub fn rl_load_compute_shader_program(shader_id: u32) -> u32;
/// Dispatch compute shader (equivalent to *draw* for graphics pipeline)
pub fn rl_compute_shader_dispatch(group_x: u32, group_y: u32, group_z: u32);

// Shader buffer storage object management (ssbo)
/// Load shader storage buffer object (SSBO)
pub fn rlLoadShaderBuffer(size: u32, data: *const c_void, usage_hint: i32) -> u32;
/// Unload shader storage buffer object (SSBO)
pub fn rl_unload_shader_buffer(ssboId: u32);
/// Update SSBO buffer data
pub fn rl_update_shader_buffer(id: u32, data: *const c_void, data_size: u32, offset: u32);
/// Bind SSBO buffer
pub fn rl_bind_shader_buffer(id: u32, index: u32);
/// Read SSBO buffer data (GPU->CPU)
pub fn rl_read_shader_buffer(id: u32, dest: *mut c_void, count: u32, offset: u32);
/// Copy SSBO data between buffers
pub fn rl_copy_shader_buffer(destId: u32, srcId: u32, dest_offset: u32, src_offset: u32, count: u32);
/// Get SSBO buffer size
pub fn rlGetShaderBufferSize(id: u32) -> u32;

// Buffer management
/// Bind image texture
pub fn rl_bind_image_texture(id: u32, index: u32, format: i32, readonly: bool);

// Matrix state management
/// Get internal modelview matrix
pub fn rl_get_matrix_modelview() -> ffi::Matrix;
/// Get internal projection matrix
pub fn rl_get_matrix_projection() -> ffi::Matrix;
/// Get internal accumulated transform matrix
pub fn rl_get_matrix_transform() -> ffi::Matrix;
/// Get internal projection matrix for stereo render (selected eye)
pub fn rl_get_matrix_projection_stereo(eye: i32) -> ffi::Matrix;
/// Get internal view offset matrix for stereo render (selected eye)
pub fn rl_get_matrix_view_offset_stereo(eye: i32) -> ffi::Matrix;
/// Set a custom projection matrix (replaces internal projection matrix)
pub fn rl_set_matrix_projection(proj: ffi::Matrix);
/// Set a custom modelview matrix (replaces internal modelview matrix)
pub fn rl_set_matrix_modelview(view: ffi::Matrix);
/// Set eyes projection matrices for stereo rendering
pub fn rl_set_matrix_projection_stereo(right: ffi::Matrix, left: ffi::Matrix);
/// Set eyes view offsets matrices for stereo rendering
pub fn rl_set_matrix_view_offset_stereo(right: ffi::Matrix, left: ffi::Matrix);

// Quick and dirty cube/quad buffers load->draw->unload
/// Load and draw a cube
pub fn rl_load_draw_cube();
/// Load and draw a quad
pub fn rl_load_draw_quad();


#[link(name = "raylib")]
unsafe extern "C" {
    static texShapes: ffi::Texture2D;
    static texShapesRec: ffi::Rectangle;
}

#[inline]
pub fn tex_shapes() -> &'static ffi::Texture2D {
    unsafe { &texShapes }
}

#[inline]
pub fn tex_shapes_size() -> (i32, i32) {
    unsafe { (texShapes.width, texShapes.height) }
}

#[inline]
pub fn tex_shapes_rec() -> Rectangle {
    unsafe { Rectangle::from(texShapesRec) }
}

pub struct RlglTexture<'a, D: ?Sized>(&'a mut D);

impl<D: ?Sized> Drop for RlglTexture<'_, D> {
    #[inline]
    fn drop(&mut self) {
        unsafe { ffi::rlSetTexture(0); }
    }
}

impl<D: ?Sized> RlglTexture<'_, D> {
    /// Initialize drawing mode (how to organize vertex)
    #[inline]
    pub fn rl_begin_quads(&mut self) -> RaylibRlglQuads<'_, Self> {
        unsafe { ffi::rlBegin(ffi::RL_QUADS as i32); }
        RaylibRlglQuads(self)
    }
}

pub struct RaylibRlglLines<'a, D: ?Sized>(&'a mut D);

impl<D: ?Sized> Drop for RaylibRlglLines<'_, D> {
    /// Finish vertex providing
    #[inline]
    fn drop(&mut self) {
        unsafe { ffi::rlEnd(); }
    }
}

pub struct RaylibRlglTriangles<'a, D: ?Sized>(&'a mut D);

impl<D: ?Sized> Drop for RaylibRlglTriangles<'_, D> {
    /// Finish vertex providing
    #[inline]
    fn drop(&mut self) {
        unsafe { ffi::rlEnd(); }
    }
}

impl<D: ?Sized> RaylibRlglTriangles<'_, D> {
    /// Define three vertices (position) - 2x3 float
    #[inline]
    pub fn rl_triangle2f(&mut self, p0: (f32, f32), p1: (f32, f32), p2: (f32, f32)) {
        self.rl_vertex2f(p0.0, p0.1);
        self.rl_vertex2f(p1.0, p1.1);
        self.rl_vertex2f(p2.0, p2.1);
    }

    /// Define one vertex (normal) - 3 float \
    /// NOTE: Normals limited to TRIANGLES only?
    #[inline]
    pub fn rl_normal3f(&mut self, x: f32, y: f32, z: f32) {
        unsafe { ffi::rlNormal3f(x, y, z); }
    }
}

pub struct RaylibRlglQuads<'a, D: ?Sized>(&'a mut D);

impl<D: ?Sized> Drop for RaylibRlglQuads<'_, D> {
    /// Finish vertex providing
    #[inline]
    fn drop(&mut self) {
        unsafe { ffi::rlEnd(); }
    }
}

impl<D: ?Sized> RaylibRlglQuads<'_, D> {
    /// Define one vertex (texture coordinate) - 2 float \
    /// NOTE: Texture coordinates are limited to QUADS only
    #[inline]
    pub fn rl_tex_coord2f(&mut self, x: f32, y: f32) {
        unsafe { ffi::rlTexCoord2f(x, y); }
    }

    /// Define one vertex (texture coordinate) - 2 float \
    /// and one vertex (position) - 2 float \
    /// NOTE: Texture coordinates are limited to QUADS only
    #[inline]
    pub fn rl_tex_coord_vertex2f(&mut self, coord: (f32, f32), vert: (f32, f32)) {
        self.rl_tex_coord2f(coord.0, coord.1);
        self.rl_vertex2f(vert.0, vert.1);
    }

    /// Define one vertex (normal) - 3 float \
    /// NOTE: Normals limited to TRIANGLES only?
    #[inline]
    pub fn rl_normal3f(&mut self, x: f32, y: f32, z: f32) {
        unsafe { ffi::rlNormal3f(x, y, z); }
    }

    /// Define four vertices (texture coordinate) - 2x4 float \
    /// and four vertices (position) - 2x4 float \
    /// NOTE: Texture coordinates are limited to QUADS only
    #[inline]
    pub fn rl_tex_quad2f(
        &mut self,
        coord0: (f32, f32), vert0: (f32, f32),
        coord1: (f32, f32), vert1: (f32, f32),
        coord2: (f32, f32), vert2: (f32, f32),
        coord3: (f32, f32), vert3: (f32, f32),
    ) {
        self.rl_tex_coord_vertex2f(coord0, vert0);
        self.rl_tex_coord_vertex2f(coord1, vert1);
        self.rl_tex_coord_vertex2f(coord2, vert2);
        self.rl_tex_coord_vertex2f(coord3, vert3);
    }
}

pub trait RaylibRlglDraw {
    /// Define one vertex (position) - 2 int
    #[inline]
    fn rl_vertex2i(&mut self, x: i32, y: i32) {
        unsafe { ffi::rlVertex2i(x, y); }
    }

    /// Define one vertex (position) - 2 float
    #[inline]
    fn rl_vertex2f(&mut self, x: f32, y: f32) {
        unsafe { ffi::rlVertex2f(x, y); }
    }

    /// Define one vertex (position) - 3 float
    #[inline]
    fn rl_vertex3f(&mut self, x: f32, y: f32, z: f32) {
        unsafe { ffi::rlVertex3f(x, y, z); }
    }

    /// Define one vertex (color) - 4 byte
    #[inline]
    fn rl_color4ub(&mut self, r: u8, g: u8, b: u8, a: u8) {
        unsafe { ffi::rlColor4ub(r, g, b, a); }
    }

    /// Define one vertex (color) - 3 float
    #[inline]
    fn rl_color3f(&mut self, r: f32, g: f32, b: f32) {
        unsafe { ffi::rlColor3f(r, g, b); }
    }

    /// Define one vertex (color) - 4 float
    #[inline]
    fn rl_color4f(&mut self, r: f32, g: f32, b: f32, a: f32) {
        unsafe { ffi::rlColor4f(r, g, b, a); }
    }
}

impl<D: ?Sized> RaylibRlglDraw for RaylibRlglLines<'_, D> {}
impl<D: ?Sized> RaylibRlglDraw for RaylibRlglTriangles<'_, D> {}
impl<D: ?Sized> RaylibRlglDraw for RaylibRlglQuads<'_, D> {}

#[cfg(test)]
mod tests {
    use raylib::prelude::*;
    use rltest::*;
    use super::*;

    #[test]
    fn test0() {
        rl_test("test0", 640, 480, 60, |rl| {
            let texture = RaylibTestWrapper::load_texture_from_image(rl, &Image::gen_image_gradient_square(32, 32, 0.5, Color::RED, Color::BLUE))?;
            rl.run(|rl| {
                if rl.is_key_pressed(KeyboardKey::KEY_ENTER) {
                    success!()
                }
                rl.begin_drawing(Color::BLACK, |d| {
                    let mut d = d.begin_rlgl();
                    let mut d = d.rl_set_texture(&texture);
                    let mut d = d.rl_begin_quads();

                    d.rl_color4ub(255, 255, 255, 255);
                    d.rl_normal3f(0.0, 0.0, 1.0);

                    d.rl_tex_quad2f(
                        (0.0, 0.0), ( 0.0,  0.0),
                        (0.0, 1.0), ( 0.0, 32.0),
                        (1.0, 1.0), (32.0, 32.0),
                        (1.0, 0.0), (32.0,  0.0),
                    );
                })
            })
        }).expect("rejected");
    }
}
